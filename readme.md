В данный момент я всё ещё занимаюсь конфигурацией окружения, поэтому в наличии только тестовая заготовка для будущей сцены.

# Что это такое?

Я это планирую как точку входа - первое, с чем столкнутся юзеры. Это лендинг с информацией обо мне и моём проекте, здесь будет расположена
форма для подачи заявки. Весь стек планируется таким: 

- Node js сервер для обслуживания фронта
- Cобственная система аналитики
- RabbitMQ 
- Бэк на Go с собственной админкой
- Redis для кэша SSR
- Mysql в качестве бд
- React, redux, scss, three js (r3f) - фронт для лендинга
- Vue, Nuxt - внутренний фронт платформы
- Angular - фронт админок
- Vite и webpack для сборки фронтов

# Запуск

В проекте есть зависимость ``@evolianka/eslint-plugin-evolianka`` - это мой пакет из приватного репо.
Пока он в тестовом режиме. Нужно его удалить, если он есть.

напрямую

```
cd ./app 
npm install 
npm run dev
```

через докер (если у вас мак ос или виндовс, прочитайте всё что ниже; если линукс, можете пропустить);

Из-за разных файловых систем при расшаривании папок с хоста ломается hot module replacement и в принципе всё, что касается
слежки за файловой системой. Нормально это работает только в связке **linux на хосте -> linux в контейнере**. Я
экспериментировал очень много: пробовал врубать синхронизацию файлов на хосте и внутри контейнера, но мне это не понравилось
из-за того, что мы сталкиваемся с необходимостью ставить пакеты отдельно на хосте и в контейнере и это создаёт 
множество неудобств, когда нужно что-то удалить или добавить; кроме того могут возникать рассинхроны при разных сценариях:
например, когда контейнер упадёт с ошибкой.

Я также пробовал организовать работу внутри контейнера - это тоже неудобно, но показалось, что это один из лучших вариантов.
Нужно много настраивать среду: либо пробрасывать внутрь контейнера, либо устанавливать туда всё: гит, креды, nvm и прочее ПО.

И я также экспериментировал с конфигурациями вебпака, nodemon и другие штуки. По факту их можно заставить топорно отслеживать изменения:
поставить различные флаги poll: true, legacyWatch: true и т.д. в зависимости от того, что мы используем, тогда изменения файлов
будут отслеживаться путём путём опроса, а не путём ожидания событий от файловой системы, 
это может чудовищно ронять производительность по мере роста проекта и даже на текущем этапе
у меня периодически жаловалась сама ide на то, что всё медленно работает. 

В общем, на мой взгляд, тут два удобных варианта: работать прям внутри контейнера и не пытаться пробросить папку с хоста
или из-под wsl/через colima на виндовс и мак ос соответственно. Первый вариант, мне кажется, больше соответствует философии
контейнеризации и ещё больше упрощает разворачивание проекта в разных средах. Возможно, в будущем я к нему вернусь, когда
вновь захочу отрефакторить дев режим.

## windows
все дальнейшие операции надо выполнять под wsl и никак иначе

## mac os 
этого я не пробовал, т.к. у меня нет мак ос, но по своему опыту работы с докером припоминаю, что под мак ос хорошо
работает colima

``` 
sh prepare-docker.sh //либо вручную скопировать в корень и переименовать файлы из папки docker, убрав example из названия 
docker compose build
docker compose up
```

В данный момент докер сконфигурирован только для дев режима.



